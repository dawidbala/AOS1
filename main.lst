   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	_LCD_OutNibble
  12               	_LCD_OutNibble:
  13               	.LFB11:
  14               		.file 1 "lib/HD44780.c"
   1:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
   2:lib/HD44780.c **** // Wyœwietlacz alfanumeryczny ze sterownikiem HD44780
   3:lib/HD44780.c **** // Sterowanie w trybie 4-bitowym bez odczytu flagi zajêtoœci
   4:lib/HD44780.c **** // z dowolnym przypisaniem sygna³ów steruj¹cych
   5:lib/HD44780.c **** // Plik : HD44780.c	
   6:lib/HD44780.c **** // Mikrokontroler : Atmel AVR
   7:lib/HD44780.c **** // Kompilator : avr-gcc
   8:lib/HD44780.c **** // Autor : Rados³aw Kwiecieñ
   9:lib/HD44780.c **** // ród³o : http://radzio.dxp.pl/hd44780/
  10:lib/HD44780.c **** // Data : 24.03.2007
  11:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  12:lib/HD44780.c **** 
  13:lib/HD44780.c **** #include "HD44780.h"
  14:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  15:lib/HD44780.c **** //
  16:lib/HD44780.c **** // Funkcja wystawiaj¹ca pó³bajt na magistralê danych
  17:lib/HD44780.c **** //
  18:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  19:lib/HD44780.c **** void _LCD_OutNibble(unsigned char nibbleToWrite)
  20:lib/HD44780.c **** {
  15               		.loc 1 20 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  21:lib/HD44780.c **** if(nibbleToWrite & 0x01)
  22               		.loc 1 21 0
  23 0000 80FF      		sbrs r24,0
  24 0002 00C0      		rjmp .L2
  22:lib/HD44780.c **** 	LCD_DB4_PORT |= LCD_DB4;
  25               		.loc 1 22 0
  26 0004 AB9A      		sbi 0x15,3
  27 0006 00C0      		rjmp .L3
  28               	.L2:
  23:lib/HD44780.c **** else
  24:lib/HD44780.c **** 	LCD_DB4_PORT  &= ~LCD_DB4;
  29               		.loc 1 24 0
  30 0008 AB98      		cbi 0x15,3
  31               	.L3:
  25:lib/HD44780.c **** 
  26:lib/HD44780.c **** if(nibbleToWrite & 0x02)
  32               		.loc 1 26 0
  33 000a 81FF      		sbrs r24,1
  34 000c 00C0      		rjmp .L4
  27:lib/HD44780.c **** 	LCD_DB5_PORT |= LCD_DB5;
  35               		.loc 1 27 0
  36 000e AA9A      		sbi 0x15,2
  37 0010 00C0      		rjmp .L5
  38               	.L4:
  28:lib/HD44780.c **** else
  29:lib/HD44780.c **** 	LCD_DB5_PORT  &= ~LCD_DB5;
  39               		.loc 1 29 0
  40 0012 AA98      		cbi 0x15,2
  41               	.L5:
  30:lib/HD44780.c **** 
  31:lib/HD44780.c **** if(nibbleToWrite & 0x04)
  42               		.loc 1 31 0
  43 0014 82FF      		sbrs r24,2
  44 0016 00C0      		rjmp .L6
  32:lib/HD44780.c **** 	LCD_DB6_PORT |= LCD_DB6;
  45               		.loc 1 32 0
  46 0018 A99A      		sbi 0x15,1
  47 001a 00C0      		rjmp .L7
  48               	.L6:
  33:lib/HD44780.c **** else
  34:lib/HD44780.c **** 	LCD_DB6_PORT  &= ~LCD_DB6;
  49               		.loc 1 34 0
  50 001c A998      		cbi 0x15,1
  51               	.L7:
  35:lib/HD44780.c **** 
  36:lib/HD44780.c **** if(nibbleToWrite & 0x08)
  52               		.loc 1 36 0
  53 001e 83FF      		sbrs r24,3
  54 0020 00C0      		rjmp .L8
  55               	.LVL1:
  56               	.LBB20:
  57               	.LBB21:
  37:lib/HD44780.c **** 	LCD_DB7_PORT |= LCD_DB7;
  58               		.loc 1 37 0
  59 0022 A89A      		sbi 0x15,0
  60 0024 0895      		ret
  61               	.LVL2:
  62               	.L8:
  63               	.LBE21:
  64               	.LBE20:
  38:lib/HD44780.c **** else
  39:lib/HD44780.c **** 	LCD_DB7_PORT  &= ~LCD_DB7;
  65               		.loc 1 39 0
  66 0026 A898      		cbi 0x15,0
  67 0028 0895      		ret
  68               		.cfi_endproc
  69               	.LFE11:
  71               	.global	_LCD_Write
  73               	_LCD_Write:
  74               	.LFB12:
  40:lib/HD44780.c **** }
  41:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  42:lib/HD44780.c **** //
  43:lib/HD44780.c **** // Funkcja zapisu bajtu do wyœwietacza (bez rozró¿nienia instrukcja/dane).
  44:lib/HD44780.c **** //
  45:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  46:lib/HD44780.c **** void _LCD_Write(unsigned char dataToWrite)
  47:lib/HD44780.c **** {
  75               		.loc 1 47 0
  76               		.cfi_startproc
  77               	.LVL3:
  78 002a CF93      		push r28
  79               	.LCFI0:
  80               		.cfi_def_cfa_offset 3
  81               		.cfi_offset 28, -2
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 1 */
  85               	.L__stack_usage = 1
  86 002c C82F      		mov r28,r24
  48:lib/HD44780.c **** LCD_E_PORT |= LCD_E;
  87               		.loc 1 48 0
  88 002e AC9A      		sbi 0x15,4
  49:lib/HD44780.c **** _LCD_OutNibble(dataToWrite >> 4);
  89               		.loc 1 49 0
  90 0030 8295      		swap r24
  91               	.LVL4:
  92 0032 8F70      		andi r24,lo8(15)
  93 0034 0E94 0000 		call _LCD_OutNibble
  94               	.LVL5:
  50:lib/HD44780.c **** LCD_E_PORT &= ~LCD_E;
  95               		.loc 1 50 0
  96 0038 AC98      		cbi 0x15,4
  51:lib/HD44780.c **** LCD_E_PORT |= LCD_E;
  97               		.loc 1 51 0
  98 003a AC9A      		sbi 0x15,4
  52:lib/HD44780.c **** _LCD_OutNibble(dataToWrite);
  99               		.loc 1 52 0
 100 003c 8C2F      		mov r24,r28
 101 003e 0E94 0000 		call _LCD_OutNibble
 102               	.LVL6:
  53:lib/HD44780.c **** LCD_E_PORT &= ~LCD_E;
 103               		.loc 1 53 0
 104 0042 AC98      		cbi 0x15,4
 105               	.LVL7:
 106               	.LBB22:
 107               	.LBB23:
 108               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 109               		.loc 2 245 0
 110 0044 87EC      		ldi r24,lo8(199)
 111 0046 90E0      		ldi r25,hi8(199)
 112 0048 0197      		1: sbiw r24,1
 113 004a 01F4      		brne 1b
 114 004c 00C0      		rjmp .
 115 004e 0000      		nop
 116               	/* epilogue start */
 117               	.LBE23:
 118               	.LBE22:
  54:lib/HD44780.c **** _delay_us(50);
  55:lib/HD44780.c **** }
 119               		.loc 1 55 0
 120 0050 CF91      		pop r28
 121               	.LVL8:
 122 0052 0895      		ret
 123               		.cfi_endproc
 124               	.LFE12:
 126               	.global	LCD_WriteCommand
 128               	LCD_WriteCommand:
 129               	.LFB13:
  56:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  57:lib/HD44780.c **** //
  58:lib/HD44780.c **** // Funkcja zapisu rozkazu do wyœwietlacza
  59:lib/HD44780.c **** //
  60:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  61:lib/HD44780.c **** void LCD_WriteCommand(unsigned char commandToWrite)
  62:lib/HD44780.c **** {
 130               		.loc 1 62 0
 131               		.cfi_startproc
 132               	.LVL9:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
  63:lib/HD44780.c **** LCD_RS_PORT &= ~LCD_RS;
 137               		.loc 1 63 0
 138 0054 AD98      		cbi 0x15,5
  64:lib/HD44780.c **** _LCD_Write(commandToWrite);
 139               		.loc 1 64 0
 140 0056 0C94 0000 		jmp _LCD_Write
 141               	.LVL10:
 142               		.cfi_endproc
 143               	.LFE13:
 145               	.global	LCD_WriteData
 147               	LCD_WriteData:
 148               	.LFB14:
  65:lib/HD44780.c **** }
  66:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  67:lib/HD44780.c **** //
  68:lib/HD44780.c **** // Funkcja zapisu danych do pamiêci wyœwietlacza
  69:lib/HD44780.c **** //
  70:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  71:lib/HD44780.c **** void LCD_WriteData(unsigned char dataToWrite)
  72:lib/HD44780.c **** {
 149               		.loc 1 72 0
 150               		.cfi_startproc
 151               	.LVL11:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  73:lib/HD44780.c **** LCD_RS_PORT |= LCD_RS;
 156               		.loc 1 73 0
 157 005a AD9A      		sbi 0x15,5
  74:lib/HD44780.c **** _LCD_Write(dataToWrite);
 158               		.loc 1 74 0
 159 005c 0C94 0000 		jmp _LCD_Write
 160               	.LVL12:
 161               		.cfi_endproc
 162               	.LFE14:
 164               	.global	LCD_WriteText
 166               	LCD_WriteText:
 167               	.LFB15:
  75:lib/HD44780.c **** }
  76:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  77:lib/HD44780.c **** //
  78:lib/HD44780.c **** // Funkcja wyœwietlenia napisu na wyswietlaczu.
  79:lib/HD44780.c **** //
  80:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  81:lib/HD44780.c **** void LCD_WriteText(char * text)
  82:lib/HD44780.c **** {
 168               		.loc 1 82 0
 169               		.cfi_startproc
 170               	.LVL13:
 171 0060 CF93      		push r28
 172               	.LCFI1:
 173               		.cfi_def_cfa_offset 3
 174               		.cfi_offset 28, -2
 175 0062 DF93      		push r29
 176               	.LCFI2:
 177               		.cfi_def_cfa_offset 4
 178               		.cfi_offset 29, -3
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 2 */
 182               	.L__stack_usage = 2
 183 0064 EC01      		movw r28,r24
 184               	.LVL14:
 185               	.L15:
  83:lib/HD44780.c **** while(*text)
 186               		.loc 1 83 0 discriminator 1
 187 0066 8991      		ld r24,Y+
 188               	.LVL15:
 189 0068 8823      		tst r24
 190 006a 01F0      		breq .L17
 191               	.LVL16:
  84:lib/HD44780.c ****   LCD_WriteData(*text++);
 192               		.loc 1 84 0
 193 006c 0E94 0000 		call LCD_WriteData
 194               	.LVL17:
 195 0070 00C0      		rjmp .L15
 196               	.LVL18:
 197               	.L17:
 198               	/* epilogue start */
  85:lib/HD44780.c **** }
 199               		.loc 1 85 0
 200 0072 DF91      		pop r29
 201 0074 CF91      		pop r28
 202               	.LVL19:
 203 0076 0895      		ret
 204               		.cfi_endproc
 205               	.LFE15:
 207               	.global	LCD_GoTo
 209               	LCD_GoTo:
 210               	.LFB16:
  86:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  87:lib/HD44780.c **** //
  88:lib/HD44780.c **** // Funkcja ustawienia wspó³rzêdnych ekranowych
  89:lib/HD44780.c **** //
  90:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  91:lib/HD44780.c **** void LCD_GoTo(unsigned char x, unsigned char y)
  92:lib/HD44780.c **** {
 211               		.loc 1 92 0
 212               		.cfi_startproc
 213               	.LVL20:
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 0 */
 217               	.L__stack_usage = 0
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 218               		.loc 1 93 0
 219 0078 90E4      		ldi r25,lo8(64)
 220 007a 699F      		mul r22,r25
 221 007c 800D      		add r24,r0
 222 007e 1124      		clr __zero_reg__
 223               	.LVL21:
 224 0080 8068      		ori r24,lo8(-128)
 225 0082 0C94 0000 		jmp LCD_WriteCommand
 226               	.LVL22:
 227               		.cfi_endproc
 228               	.LFE16:
 230               	.global	LCD_Clear
 232               	LCD_Clear:
 233               	.LFB17:
  94:lib/HD44780.c **** }
  95:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
  96:lib/HD44780.c **** //
  97:lib/HD44780.c **** // Funkcja czyszczenia ekranu wyœwietlacza.
  98:lib/HD44780.c **** //
  99:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
 100:lib/HD44780.c **** void LCD_Clear(void)
 101:lib/HD44780.c **** {
 234               		.loc 1 101 0
 235               		.cfi_startproc
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 0 */
 239               	.L__stack_usage = 0
 102:lib/HD44780.c **** LCD_WriteCommand(HD44780_CLEAR);
 240               		.loc 1 102 0
 241 0086 81E0      		ldi r24,lo8(1)
 242 0088 0E94 0000 		call LCD_WriteCommand
 243               	.LVL23:
 244               	.LBB24:
 245               	.LBB25:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 246               		.loc 2 163 0
 247 008c 8FE3      		ldi r24,lo8(7999)
 248 008e 9FE1      		ldi r25,hi8(7999)
 249 0090 0197      		1: sbiw r24,1
 250 0092 01F4      		brne 1b
 251 0094 00C0      		rjmp .
 252 0096 0000      		nop
 253 0098 0895      		ret
 254               	.LBE25:
 255               	.LBE24:
 256               		.cfi_endproc
 257               	.LFE17:
 259               	.global	LCD_Home
 261               	LCD_Home:
 262               	.LFB18:
 103:lib/HD44780.c **** _delay_ms(2);
 104:lib/HD44780.c **** }
 105:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
 106:lib/HD44780.c **** //
 107:lib/HD44780.c **** // Funkcja przywrócenia pocz¹tkowych wspó³rzêdnych wyœwietlacza.
 108:lib/HD44780.c **** //
 109:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
 110:lib/HD44780.c **** void LCD_Home(void)
 111:lib/HD44780.c **** {
 263               		.loc 1 111 0
 264               		.cfi_startproc
 265               	/* prologue: function */
 266               	/* frame size = 0 */
 267               	/* stack size = 0 */
 268               	.L__stack_usage = 0
 112:lib/HD44780.c **** LCD_WriteCommand(HD44780_HOME);
 269               		.loc 1 112 0
 270 009a 82E0      		ldi r24,lo8(2)
 271 009c 0E94 0000 		call LCD_WriteCommand
 272               	.LVL24:
 273               	.LBB26:
 274               	.LBB27:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 275               		.loc 2 163 0
 276 00a0 8FE3      		ldi r24,lo8(7999)
 277 00a2 9FE1      		ldi r25,hi8(7999)
 278 00a4 0197      		1: sbiw r24,1
 279 00a6 01F4      		brne 1b
 280 00a8 00C0      		rjmp .
 281 00aa 0000      		nop
 282 00ac 0895      		ret
 283               	.LBE27:
 284               	.LBE26:
 285               		.cfi_endproc
 286               	.LFE18:
 288               	.global	LCD_Initalize
 290               	LCD_Initalize:
 291               	.LFB19:
 113:lib/HD44780.c **** _delay_ms(2);
 114:lib/HD44780.c **** }
 115:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
 116:lib/HD44780.c **** //
 117:lib/HD44780.c **** // Procedura inicjalizacji kontrolera HD44780.
 118:lib/HD44780.c **** //
 119:lib/HD44780.c **** //-------------------------------------------------------------------------------------------------
 120:lib/HD44780.c **** void LCD_Initalize(void)
 121:lib/HD44780.c **** {
 292               		.loc 1 121 0
 293               		.cfi_startproc
 294 00ae CF93      		push r28
 295               	.LCFI3:
 296               		.cfi_def_cfa_offset 3
 297               		.cfi_offset 28, -2
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 1 */
 301               	.L__stack_usage = 1
 122:lib/HD44780.c **** unsigned char i;
 123:lib/HD44780.c **** LCD_DB4_DIR |= LCD_DB4; // Konfiguracja kierunku pracy wyprowadzeñ
 302               		.loc 1 123 0
 303 00b0 A39A      		sbi 0x14,3
 124:lib/HD44780.c **** LCD_DB5_DIR |= LCD_DB5; //
 304               		.loc 1 124 0
 305 00b2 A29A      		sbi 0x14,2
 125:lib/HD44780.c **** LCD_DB6_DIR |= LCD_DB6; //
 306               		.loc 1 125 0
 307 00b4 A19A      		sbi 0x14,1
 126:lib/HD44780.c **** LCD_DB7_DIR |= LCD_DB7; //
 308               		.loc 1 126 0
 309 00b6 A09A      		sbi 0x14,0
 127:lib/HD44780.c **** LCD_E_DIR 	|= LCD_E;   //
 310               		.loc 1 127 0
 311 00b8 A49A      		sbi 0x14,4
 128:lib/HD44780.c **** LCD_RS_DIR 	|= LCD_RS;  //
 312               		.loc 1 128 0
 313 00ba A59A      		sbi 0x14,5
 314               	.LVL25:
 315               	.LBB28:
 316               	.LBB29:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 317               		.loc 2 163 0
 318 00bc 8FE5      		ldi r24,lo8(-5537)
 319 00be 9AEE      		ldi r25,hi8(-5537)
 320 00c0 0197      		1: sbiw r24,1
 321 00c2 01F4      		brne 1b
 322 00c4 00C0      		rjmp .
 323 00c6 0000      		nop
 324               	.LBE29:
 325               	.LBE28:
 129:lib/HD44780.c **** _delay_ms(15); // oczekiwanie na ustalibizowanie siê napiecia zasilajacego
 130:lib/HD44780.c **** LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
 326               		.loc 1 130 0
 327 00c8 AD98      		cbi 0x15,5
 131:lib/HD44780.c **** LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E
 328               		.loc 1 131 0
 329 00ca AC98      		cbi 0x15,4
 330               	.LVL26:
 331 00cc C3E0      		ldi r28,lo8(3)
 332               	.LVL27:
 333               	.L23:
 132:lib/HD44780.c **** 
 133:lib/HD44780.c **** for(i = 0; i < 3; i++) // trzykrotne powtórzenie bloku instrukcji
 134:lib/HD44780.c ****   {
 135:lib/HD44780.c ****   LCD_E_PORT |= LCD_E; //  E = 1
 334               		.loc 1 135 0 discriminator 2
 335 00ce AC9A      		sbi 0x15,4
 136:lib/HD44780.c ****   _LCD_OutNibble(0x03); // tryb 8-bitowy
 336               		.loc 1 136 0 discriminator 2
 337 00d0 83E0      		ldi r24,lo8(3)
 338 00d2 0E94 0000 		call _LCD_OutNibble
 339               	.LVL28:
 137:lib/HD44780.c ****   LCD_E_PORT &= ~LCD_E; // E = 0
 340               		.loc 1 137 0 discriminator 2
 341 00d6 AC98      		cbi 0x15,4
 342               	.LVL29:
 343               	.LBB30:
 344               	.LBB31:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 345               		.loc 2 163 0 discriminator 2
 346 00d8 8FE1      		ldi r24,lo8(19999)
 347 00da 9EE4      		ldi r25,hi8(19999)
 348 00dc 0197      		1: sbiw r24,1
 349 00de 01F4      		brne 1b
 350 00e0 00C0      		rjmp .
 351 00e2 0000      		nop
 352               	.LVL30:
 353 00e4 C150      		subi r28,lo8(-(-1))
 354               	.LVL31:
 355               	.LBE31:
 356               	.LBE30:
 133:lib/HD44780.c **** for(i = 0; i < 3; i++) // trzykrotne powtórzenie bloku instrukcji
 357               		.loc 1 133 0 discriminator 2
 358 00e6 01F4      		brne .L23
 138:lib/HD44780.c ****   _delay_ms(5); // czekaj 5ms
 139:lib/HD44780.c ****   }
 140:lib/HD44780.c **** 
 141:lib/HD44780.c **** LCD_E_PORT |= LCD_E; // E = 1
 359               		.loc 1 141 0
 360 00e8 AC9A      		sbi 0x15,4
 142:lib/HD44780.c **** _LCD_OutNibble(0x02); // tryb 4-bitowy
 361               		.loc 1 142 0
 362 00ea 82E0      		ldi r24,lo8(2)
 363 00ec 0E94 0000 		call _LCD_OutNibble
 364               	.LVL32:
 143:lib/HD44780.c **** LCD_E_PORT &= ~LCD_E; // E = 0
 365               		.loc 1 143 0
 366 00f0 AC98      		cbi 0x15,4
 367               	.LVL33:
 368               	.LBB32:
 369               	.LBB33:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 370               		.loc 2 163 0
 371 00f2 8FE9      		ldi r24,lo8(3999)
 372 00f4 9FE0      		ldi r25,hi8(3999)
 373 00f6 0197      		1: sbiw r24,1
 374 00f8 01F4      		brne 1b
 375 00fa 00C0      		rjmp .
 376 00fc 0000      		nop
 377               	.LBE33:
 378               	.LBE32:
 144:lib/HD44780.c **** 
 145:lib/HD44780.c **** _delay_ms(1); // czekaj 1ms 
 146:lib/HD44780.c **** LCD_WriteCommand(HD44780_FUNCTION_SET | HD44780_FONT5x7 | HD44780_TWO_LINE | HD44780_4_BIT); // int
 379               		.loc 1 146 0
 380 00fe 88E2      		ldi r24,lo8(40)
 381 0100 0E94 0000 		call LCD_WriteCommand
 382               	.LVL34:
 147:lib/HD44780.c **** LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_OFF); // wy³¹czenie wyswietlacza
 383               		.loc 1 147 0
 384 0104 88E0      		ldi r24,lo8(8)
 385 0106 0E94 0000 		call LCD_WriteCommand
 386               	.LVL35:
 148:lib/HD44780.c **** LCD_WriteCommand(HD44780_CLEAR); // czyszczenie zawartosæi pamieci DDRAM
 387               		.loc 1 148 0
 388 010a 81E0      		ldi r24,lo8(1)
 389 010c 0E94 0000 		call LCD_WriteCommand
 390               	.LVL36:
 391               	.LBB34:
 392               	.LBB35:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 393               		.loc 2 163 0
 394 0110 8FE3      		ldi r24,lo8(7999)
 395 0112 9FE1      		ldi r25,hi8(7999)
 396 0114 0197      		1: sbiw r24,1
 397 0116 01F4      		brne 1b
 398 0118 00C0      		rjmp .
 399 011a 0000      		nop
 400               	.LBE35:
 401               	.LBE34:
 149:lib/HD44780.c **** _delay_ms(2);
 150:lib/HD44780.c **** LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);// inkrementa
 402               		.loc 1 150 0
 403 011c 86E0      		ldi r24,lo8(6)
 404 011e 0E94 0000 		call LCD_WriteCommand
 405               	.LVL37:
 151:lib/HD44780.c **** LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_ON | HD44780_CURSOR_OFF | HD44780_CURSOR_N
 406               		.loc 1 151 0
 407 0122 8CE0      		ldi r24,lo8(12)
 408               	/* epilogue start */
 152:lib/HD44780.c **** }
 409               		.loc 1 152 0
 410 0124 CF91      		pop r28
 411               	.LVL38:
 151:lib/HD44780.c **** LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_ON | HD44780_CURSOR_OFF | HD44780_CURSOR_N
 412               		.loc 1 151 0
 413 0126 0C94 0000 		jmp LCD_WriteCommand
 414               	.LVL39:
 415               		.cfi_endproc
 416               	.LFE19:
 418               	.global	ADC_init
 420               	ADC_init:
 421               	.LFB20:
 422               		.file 3 "lib/ADC.c"
   1:lib/ADC.c     **** /*
   2:lib/ADC.c     ****  * ADC.c
   3:lib/ADC.c     ****  *
   4:lib/ADC.c     ****  * Created: 2014-02-12 16:46:07
   5:lib/ADC.c     ****  *  Author: Piotr
   6:lib/ADC.c     ****  */ 
   7:lib/ADC.c     **** #include "ADC.h"
   8:lib/ADC.c     **** 
   9:lib/ADC.c     **** void ADC_init(void){
 423               		.loc 3 9 0
 424               		.cfi_startproc
 425               	/* prologue: function */
 426               	/* frame size = 0 */
 427               	/* stack size = 0 */
 428               	.L__stack_usage = 0
  10:lib/ADC.c     **** 	ADMUX |= (1<<REFS0);//ustawiam napiêcie odniesienia na AVCC (napiêcie zasilania uk³adu ~5V)
 429               		.loc 3 10 0
 430 012a 3E9A      		sbi 0x7,6
  11:lib/ADC.c     **** 	ADCSRA |= (1<<ADPS0)|(1<<ADPS1)|(1<<ADPS2);//ustawienie prescalera na 128 = czêstotliwoœæ taktowan
 431               		.loc 3 11 0
 432 012c 86B1      		in r24,0x6
 433 012e 8760      		ori r24,lo8(7)
 434 0130 86B9      		out 0x6,r24
  12:lib/ADC.c     **** 	ADCSRA |= (1<<ADEN);//w³¹czenie przetwornika
 435               		.loc 3 12 0
 436 0132 379A      		sbi 0x6,7
 437 0134 0895      		ret
 438               		.cfi_endproc
 439               	.LFE20:
 441               	.global	ADC_get
 443               	ADC_get:
 444               	.LFB21:
  13:lib/ADC.c     **** 	
  14:lib/ADC.c     **** }
  15:lib/ADC.c     **** uint16_t ADC_get(uint8_t channel){
 445               		.loc 3 15 0
 446               		.cfi_startproc
 447               	.LVL40:
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 0 */
 451               	.L__stack_usage = 0
  16:lib/ADC.c     **** 	ADMUX=(ADMUX&0b11100000)|(channel&0b00011111);//ustawiam kana³
 452               		.loc 3 16 0
 453 0136 97B1      		in r25,0x7
 454 0138 8F71      		andi r24,lo8(31)
 455               	.LVL41:
 456 013a 907E      		andi r25,lo8(-32)
 457 013c 892B      		or r24,r25
 458 013e 87B9      		out 0x7,r24
  17:lib/ADC.c     **** 	ADCSRA |= (1<<ADSC);//rozpoczynam konwersjê
 459               		.loc 3 17 0
 460 0140 369A      		sbi 0x6,6
 461               	.L27:
  18:lib/ADC.c     **** 	while(ADCSRA&(1<<ADSC));//czekamy na zakoñczenie tej konwersji
 462               		.loc 3 18 0 discriminator 1
 463 0142 3699      		sbic 0x6,6
 464 0144 00C0      		rjmp .L27
  19:lib/ADC.c     **** 	return ADC;
 465               		.loc 3 19 0
 466 0146 84B1      		in r24,0x4
 467 0148 95B1      		in r25,0x4+1
  20:lib/ADC.c     **** }
 468               		.loc 3 20 0
 469 014a 0895      		ret
 470               		.cfi_endproc
 471               	.LFE21:
 473               		.section	.rodata.str1.1,"aMS",@progbits,1
 474               	.LC0:
 475 0000 414F 5320 		.string	"AOS 1"
 475      3100 
 476               	.LC1:
 477 0006 7665 7273 		.string	"version: 0.1"
 477      696F 6E3A 
 477      2030 2E31 
 477      00
 478               	.LC2:
 479 0013 4C2B 00   		.string	"L+"
 480               	.LC3:
 481 0016 4C2D 00   		.string	"L-"
 482               	.LC4:
 483 0019 502F 5300 		.string	"P/S"
 484               	.LC5:
 485 001d 5300      		.string	"S"
 486               	.LC6:
 487 001f 4D00      		.string	"M"
 488               	.LC7:
 489 0021 5200      		.string	"R"
 490               	.LC8:
 491 0023 522D 00   		.string	"R-"
 492               	.LC9:
 493 0026 522B 00   		.string	"R+"
 494               		.section	.text.startup,"ax",@progbits
 495               	.global	main
 497               	main:
 498               	.LFB22:
 499               		.file 4 "main.c"
   1:main.c        **** //
   2:main.c        **** //  main.c
   3:main.c        **** //  AOS1
   4:main.c        **** //  version 0.1
   5:main.c        **** //  Created by David on 02.12.2015.
   6:main.c        **** //
   7:main.c        **** 
   8:main.c        **** #include <stdint.h>
   9:main.c        **** #include <avr/io.h>
  10:main.c        **** #include <util/delay.h>
  11:main.c        **** #include "lib/avr_compiler.h"
  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** //ObsÅ‚uga modÃ³Å‚Ã³w
  15:main.c        **** #include "lib/control_signals_conf.h" // Definicje portÃ³w,
  16:main.c        **** #include "lib/HD44780.h" // Ekran LCD
  17:main.c        **** #include "lib/HD44780.c"
  18:main.c        **** #include "lib/ADC.h" // Przetwornik analogowo-cyfrowy
  19:main.c        **** #include "lib/ADC.c"
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** // GÅ‚Ã³wna funkcja
  23:main.c        **** int main(void)
  24:main.c        **** {
 500               		.loc 4 24 0
 501               		.cfi_startproc
 502               	/* prologue: function */
 503               	/* frame size = 0 */
 504               	/* stack size = 0 */
 505               	.L__stack_usage = 0
  25:main.c        **** // Konfiguracja portÃ³w
  26:main.c        ****     Btn_DIR = 0x00;
 506               		.loc 4 26 0
 507 0000 11BA      		out 0x11,__zero_reg__
  27:main.c        ****     Btn_PORT = 0xff;
 508               		.loc 4 27 0
 509 0002 8FEF      		ldi r24,lo8(-1)
 510 0004 82BB      		out 0x12,r24
  28:main.c        ****     wLED_DIR     |= (1<<wLED);
 511               		.loc 4 28 0
 512 0006 A79A      		sbi 0x14,7
  29:main.c        ****     wLED_PORT    |= (1<<wLED);
 513               		.loc 4 29 0
 514 0008 AF9A      		sbi 0x15,7
  30:main.c        ****     
  31:main.c        ****     
  32:main.c        **** // Inicjalizacje modÃ³Å‚Ã³w
  33:main.c        ****     LCD_Initalize(); // Inicjalizacja LCD
 515               		.loc 4 33 0
 516 000a 0E94 0000 		call LCD_Initalize
 517               	.LVL42:
 518               	.LBB58:
 519               	.LBB59:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 520               		.loc 1 93 0
 521 000e 80E8      		ldi r24,lo8(-128)
 522 0010 0E94 0000 		call LCD_WriteCommand
 523               	.LVL43:
 524               	.LBE59:
 525               	.LBE58:
  34:main.c        ****     
  35:main.c        ****     
  36:main.c        **** // Ekran startowy
  37:main.c        ****     LCD_GoTo(0,0); // Kursor w pierwszyej kolumnie pierwszego wiersza.
  38:main.c        ****     LCD_WriteText("AOS 1");
 526               		.loc 4 38 0
 527 0014 80E0      		ldi r24,lo8(.LC0)
 528 0016 90E0      		ldi r25,hi8(.LC0)
 529 0018 0E94 0000 		call LCD_WriteText
 530               	.LVL44:
 531               	.LBB60:
 532               	.LBB61:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 533               		.loc 1 93 0
 534 001c 80EC      		ldi r24,lo8(-64)
 535 001e 0E94 0000 		call LCD_WriteCommand
 536               	.LVL45:
 537               	.LBE61:
 538               	.LBE60:
  39:main.c        ****     
  40:main.c        ****     LCD_GoTo(0,1); // Kursor w pierwszej kolumnie drugiego wiersza.
  41:main.c        ****     LCD_WriteText("version: 0.1");
 539               		.loc 4 41 0
 540 0022 80E0      		ldi r24,lo8(.LC1)
 541 0024 90E0      		ldi r25,hi8(.LC1)
 542 0026 0E94 0000 		call LCD_WriteText
 543               	.LVL46:
 544               	.L37:
  42:main.c        ****     
  43:main.c        ****     
  44:main.c        **** //GÅ‚Ã³wna pÄ™tla
  45:main.c        ****     while(1)
  46:main.c        ****     {
  47:main.c        **** // MENU
  48:main.c        ****       if (PIND == Btn_LeftMinus)  // L+
 545               		.loc 4 48 0
 546 002a 80B3      		in r24,0x10
 547 002c 8F37      		cpi r24,lo8(127)
 548 002e 01F4      		brne .L29
  49:main.c        ****         {
  50:main.c        ****             PORTC &= (~(1<<7));
 549               		.loc 4 50 0
 550 0030 AF98      		cbi 0x15,7
  51:main.c        ****             LCD_Clear();
 551               		.loc 4 51 0
 552 0032 0E94 0000 		call LCD_Clear
 553               	.LVL47:
 554               	.LBB62:
 555               	.LBB63:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 556               		.loc 1 93 0
 557 0036 80E8      		ldi r24,lo8(-128)
 558 0038 0E94 0000 		call LCD_WriteCommand
 559               	.LVL48:
 560               	.LBE63:
 561               	.LBE62:
  52:main.c        ****             LCD_GoTo(0,0);
  53:main.c        ****             LCD_WriteText("L+");
 562               		.loc 4 53 0
 563 003c 80E0      		ldi r24,lo8(.LC2)
 564 003e 90E0      		ldi r25,hi8(.LC2)
 565 0040 00C0      		rjmp .L38
 566               	.LVL49:
 567               	.L29:
  54:main.c        ****         }
  55:main.c        ****       else if (PIND == Btn_LeftPlus) // L-
 568               		.loc 4 55 0
 569 0042 80B3      		in r24,0x10
 570 0044 8F3B      		cpi r24,lo8(-65)
 571 0046 01F4      		brne .L31
  56:main.c        ****         {
  57:main.c        ****             PORTC |= (1<<7);
 572               		.loc 4 57 0
 573 0048 AF9A      		sbi 0x15,7
  58:main.c        ****             LCD_Clear();
 574               		.loc 4 58 0
 575 004a 0E94 0000 		call LCD_Clear
 576               	.LVL50:
 577               	.LBB64:
 578               	.LBB65:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 579               		.loc 1 93 0
 580 004e 80E8      		ldi r24,lo8(-128)
 581 0050 0E94 0000 		call LCD_WriteCommand
 582               	.LVL51:
 583               	.LBE65:
 584               	.LBE64:
  59:main.c        ****             LCD_GoTo(0,0);
  60:main.c        ****             LCD_WriteText("L-");
 585               		.loc 4 60 0
 586 0054 80E0      		ldi r24,lo8(.LC3)
 587 0056 90E0      		ldi r25,hi8(.LC3)
 588 0058 00C0      		rjmp .L38
 589               	.LVL52:
 590               	.L31:
  61:main.c        ****         }
  62:main.c        ****       else if (PIND == Btn_PS) // P/S
 591               		.loc 4 62 0
 592 005a 80B3      		in r24,0x10
 593 005c 8F3D      		cpi r24,lo8(-33)
 594 005e 01F4      		brne .L32
  63:main.c        ****         {
  64:main.c        ****             LCD_Clear();
 595               		.loc 4 64 0
 596 0060 0E94 0000 		call LCD_Clear
 597               	.LVL53:
 598               	.LBB66:
 599               	.LBB67:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 600               		.loc 1 93 0
 601 0064 80E8      		ldi r24,lo8(-128)
 602 0066 0E94 0000 		call LCD_WriteCommand
 603               	.LVL54:
 604               	.LBE67:
 605               	.LBE66:
  65:main.c        ****             LCD_GoTo(0,0);
  66:main.c        ****             LCD_WriteText("P/S");
 606               		.loc 4 66 0
 607 006a 80E0      		ldi r24,lo8(.LC4)
 608 006c 90E0      		ldi r25,hi8(.LC4)
 609 006e 00C0      		rjmp .L38
 610               	.LVL55:
 611               	.L32:
  67:main.c        ****         }
  68:main.c        ****       else if (PIND == Btn_S) // S
 612               		.loc 4 68 0
 613 0070 80B3      		in r24,0x10
 614 0072 8F3E      		cpi r24,lo8(-17)
 615 0074 01F4      		brne .L33
  69:main.c        ****         {
  70:main.c        ****           LCD_Clear();
 616               		.loc 4 70 0
 617 0076 0E94 0000 		call LCD_Clear
 618               	.LVL56:
 619               	.LBB68:
 620               	.LBB69:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 621               		.loc 1 93 0
 622 007a 80E8      		ldi r24,lo8(-128)
 623 007c 0E94 0000 		call LCD_WriteCommand
 624               	.LVL57:
 625               	.LBE69:
 626               	.LBE68:
  71:main.c        ****           LCD_GoTo(0,0);
  72:main.c        ****           LCD_WriteText("S");
 627               		.loc 4 72 0
 628 0080 80E0      		ldi r24,lo8(.LC5)
 629 0082 90E0      		ldi r25,hi8(.LC5)
 630 0084 00C0      		rjmp .L38
 631               	.LVL58:
 632               	.L33:
  73:main.c        ****         }
  74:main.c        ****       else if (PIND == Btn_M) // M
 633               		.loc 4 74 0
 634 0086 80B3      		in r24,0x10
 635 0088 873F      		cpi r24,lo8(-9)
 636 008a 01F4      		brne .L34
  75:main.c        ****         {
  76:main.c        ****             LCD_Clear();
 637               		.loc 4 76 0
 638 008c 0E94 0000 		call LCD_Clear
 639               	.LVL59:
 640               	.LBB70:
 641               	.LBB71:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 642               		.loc 1 93 0
 643 0090 80E8      		ldi r24,lo8(-128)
 644 0092 0E94 0000 		call LCD_WriteCommand
 645               	.LVL60:
 646               	.LBE71:
 647               	.LBE70:
  77:main.c        ****             LCD_GoTo(0,0);
  78:main.c        ****             LCD_WriteText("M");
 648               		.loc 4 78 0
 649 0096 80E0      		ldi r24,lo8(.LC6)
 650 0098 90E0      		ldi r25,hi8(.LC6)
 651 009a 00C0      		rjmp .L38
 652               	.LVL61:
 653               	.L34:
  79:main.c        ****         }
  80:main.c        ****       else if (PIND == Btn_Remote) // R
 654               		.loc 4 80 0
 655 009c 80B3      		in r24,0x10
 656 009e 8B3F      		cpi r24,lo8(-5)
 657 00a0 01F4      		brne .L35
  81:main.c        ****         {
  82:main.c        ****             LCD_Clear();
 658               		.loc 4 82 0
 659 00a2 0E94 0000 		call LCD_Clear
 660               	.LVL62:
 661               	.LBB72:
 662               	.LBB73:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 663               		.loc 1 93 0
 664 00a6 80E8      		ldi r24,lo8(-128)
 665 00a8 0E94 0000 		call LCD_WriteCommand
 666               	.LVL63:
 667               	.LBE73:
 668               	.LBE72:
  83:main.c        ****             LCD_GoTo(0,0);
  84:main.c        ****             LCD_WriteText("R");
 669               		.loc 4 84 0
 670 00ac 80E0      		ldi r24,lo8(.LC7)
 671 00ae 90E0      		ldi r25,hi8(.LC7)
 672 00b0 00C0      		rjmp .L38
 673               	.LVL64:
 674               	.L35:
  85:main.c        ****         }
  86:main.c        ****       else if (PIND == Btn_RightMinus) // R-
 675               		.loc 4 86 0
 676 00b2 80B3      		in r24,0x10
 677 00b4 8D3F      		cpi r24,lo8(-3)
 678 00b6 01F4      		brne .L36
  87:main.c        ****         {
  88:main.c        ****             LCD_Clear();
 679               		.loc 4 88 0
 680 00b8 0E94 0000 		call LCD_Clear
 681               	.LVL65:
 682               	.LBB74:
 683               	.LBB75:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 684               		.loc 1 93 0
 685 00bc 80E8      		ldi r24,lo8(-128)
 686 00be 0E94 0000 		call LCD_WriteCommand
 687               	.LVL66:
 688               	.LBE75:
 689               	.LBE74:
  89:main.c        ****             LCD_GoTo(0,0);
  90:main.c        ****             LCD_WriteText("R-");
 690               		.loc 4 90 0
 691 00c2 80E0      		ldi r24,lo8(.LC8)
 692 00c4 90E0      		ldi r25,hi8(.LC8)
 693 00c6 00C0      		rjmp .L38
 694               	.LVL67:
 695               	.L36:
  91:main.c        ****         }
  92:main.c        ****       else if (PIND == Btn_RightPlus) // R+
 696               		.loc 4 92 0
 697 00c8 80B3      		in r24,0x10
 698 00ca 8E3F      		cpi r24,lo8(-2)
 699 00cc 01F4      		brne .L30
  93:main.c        ****         {
  94:main.c        ****             LCD_Clear();
 700               		.loc 4 94 0
 701 00ce 0E94 0000 		call LCD_Clear
 702               	.LVL68:
 703               	.LBB76:
 704               	.LBB77:
  93:lib/HD44780.c **** LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 705               		.loc 1 93 0
 706 00d2 80E8      		ldi r24,lo8(-128)
 707 00d4 0E94 0000 		call LCD_WriteCommand
 708               	.LVL69:
 709               	.LBE77:
 710               	.LBE76:
  95:main.c        ****             LCD_GoTo(0,0);
  96:main.c        ****             LCD_WriteText("R+");
 711               		.loc 4 96 0
 712 00d8 80E0      		ldi r24,lo8(.LC9)
 713 00da 90E0      		ldi r25,hi8(.LC9)
 714               	.LVL70:
 715               	.L38:
 716 00dc 0E94 0000 		call LCD_WriteText
 717               	.LVL71:
 718               	.L30:
 719               	.LBB78:
 720               	.LBB79:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 721               		.loc 2 163 0
 722 00e0 8FE9      		ldi r24,lo8(3999)
 723 00e2 9FE0      		ldi r25,hi8(3999)
 724 00e4 0197      		1: sbiw r24,1
 725 00e6 01F4      		brne 1b
 726 00e8 00C0      		rjmp .
 727 00ea 0000      		nop
 728 00ec 00C0      		rjmp .L37
 729               	.LBE79:
 730               	.LBE78:
 731               		.cfi_endproc
 732               	.LFE22:
 734               		.text
 735               	.Letext0:
 736               		.file 5 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:2      *ABS*:0000003e __SP_H__
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:3      *ABS*:0000003d __SP_L__
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:4      *ABS*:0000003f __SREG__
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:6      *ABS*:00000001 __zero_reg__
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:12     .text:00000000 _LCD_OutNibble
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:73     .text:0000002a _LCD_Write
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:128    .text:00000054 LCD_WriteCommand
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:147    .text:0000005a LCD_WriteData
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:166    .text:00000060 LCD_WriteText
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:209    .text:00000078 LCD_GoTo
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:232    .text:00000086 LCD_Clear
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:261    .text:0000009a LCD_Home
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:290    .text:000000ae LCD_Initalize
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:420    .text:0000012a ADC_init
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:443    .text:00000136 ADC_get
/var/folders/81/7plh_tys5lqfyddsvzkdfmtr0000gp/T//ccjgsErP.s:497    .text.startup:00000000 main

UNDEFINED SYMBOLS
__do_copy_data
